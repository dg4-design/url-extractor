---
import Layout from '../layouts/Layout.astro';
import "../styles/index.scss";
import { extractUrls } from "../utils/urlExtractor";
import { generateFileName, createXmlContent } from "../utils/weblocGenerator";
---

<Layout title="URLã‚¯ãƒªãƒƒãƒ‘ãƒ¼">
  <div class="container">
    <div class="header">
      <h1>URLã‚¯ãƒªãƒƒãƒ‘ãƒ¼</h1>
    </div>

    <div class="instructions">
      <h3>ğŸ“‹ ä½¿ã„æ–¹</h3>
      <p>ãƒ†ã‚­ã‚¹ãƒˆã‚’å…¥åŠ›ã™ã‚‹ã ã‘ã§URLã‚’æŠ½å‡ºã—ã¦ã€weblocå½¢å¼ã§ä¿å­˜ã§ãã‚‹ã‚ˆï¼</p>
    </div>

    <div class="input-area">
      <textarea id="urlInput" placeholder="ãƒ†ã‚­ã‚¹ãƒˆã‚’å…¥åŠ›ã—ã¦ã­..."></textarea>
      <button id="clearButton">ã‚¯ãƒªã‚¢</button>
    </div>

    <div id="statusMessage" class="status-message"></div>

    <div id="stats" class="stats"></div>

    <div id="urlList" class="url-list"></div>

    <div id="downloadAllButtonContainer" class="download-all-container" style="display: none;">
      <button id="downloadAllButton">ã™ã¹ã¦ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ï¼ˆZIPï¼‰</button>
    </div>

    <div id="toast" class="toast"></div>
  </div>
</Layout>

<script>
  import { extractUrls } from "../utils/urlExtractor";
  import { generateFileName, createXmlContent } from "../utils/weblocGenerator";
  
  let extractedUrls: string[] = [];
  const urlInput = document.getElementById("urlInput") as HTMLTextAreaElement;
  const clearButton = document.getElementById("clearButton") as HTMLButtonElement;
  const statusMessage = document.getElementById("statusMessage") as HTMLDivElement;
  const statsElement = document.getElementById("stats") as HTMLDivElement;
  const urlListElement = document.getElementById("urlList") as HTMLDivElement;
  const downloadAllButtonContainer = document.getElementById("downloadAllButtonContainer") as HTMLDivElement;
  const downloadAllButton = document.getElementById("downloadAllButton") as HTMLButtonElement;
  const toast = document.getElementById("toast") as HTMLDivElement;

  let debounceTimer: ReturnType<typeof setTimeout>;

  // å…¥åŠ›ãƒ†ã‚­ã‚¹ãƒˆã‹ã‚‰URLã‚’æŠ½å‡ºã™ã‚‹å‡¦ç†
  function processInput() {
    statusMessage.innerHTML = '<div class="loading"></div> URLã‚’æ¢ã—ã¦ã„ã‚‹ã‚ˆ...';
    statusMessage.className = "status-message";
    
    const urls = extractUrls(urlInput.value);
    extractedUrls = urls;

    if (urls.length === 0) {
      statusMessage.textContent = "URLãŒè¦‹ã¤ã‹ã‚‰ãªã‹ã£ãŸã‚ˆ...";
      statusMessage.className = "status-message error";
      urlListElement.innerHTML = "";
      statsElement.innerHTML = "";
      downloadAllButtonContainer.style.display = "none";
      return;
    }

    statusMessage.textContent = `${urls.length}å€‹ã®URLãŒè¦‹ã¤ã‹ã£ãŸã‚ˆï¼`;
    statusMessage.className = "status-message success";
    
    updateStats();
    renderUrlList();
    downloadAllButtonContainer.style.display = "block";
  }

  // çµ±è¨ˆæƒ…å ±ã®æ›´æ–°
  function updateStats() {
    const uniqueDomains = new Set(extractedUrls.map(url => {
      try {
        return new URL(url).hostname;
      } catch (e) {
        return "unknown";
      }
    }));

    statsElement.innerHTML = `
      <div>
        <span>URLæ•°: <strong>${extractedUrls.length}</strong></span>
        <span>ãƒ‰ãƒ¡ã‚¤ãƒ³æ•°: <strong>${uniqueDomains.size}</strong></span>
      </div>
    `;
  }

  // URLãƒªã‚¹ãƒˆã®è¡¨ç¤º
  function renderUrlList() {
    urlListElement.innerHTML = "";
    
    extractedUrls.forEach(url => {
      const listItem = document.createElement("div");
      listItem.className = "url-item";
      
      const urlText = document.createElement("span");
      urlText.className = "url-text";
      urlText.textContent = url;
      
      const buttonsContainer = document.createElement("div");
      buttonsContainer.className = "button-container";
      
      const downloadButton = document.createElement("button");
      downloadButton.textContent = "ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰";
      downloadButton.onclick = () => downloadUrl(url);
      
      const removeParamsButton = document.createElement("button");
      removeParamsButton.textContent = "ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿å‰Šé™¤";
      
      try {
        const urlObj = new URL(url);
        if (urlObj.search) {
          const cleanUrl = url.split('?')[0];
          removeParamsButton.onclick = () => removeQueryParams(url, cleanUrl);
        } else {
          removeParamsButton.disabled = true;
        }
      } catch (e) {
        removeParamsButton.disabled = true;
      }
      
      buttonsContainer.appendChild(downloadButton);
      buttonsContainer.appendChild(removeParamsButton);
      
      listItem.appendChild(urlText);
      listItem.appendChild(buttonsContainer);
      
      urlListElement.appendChild(listItem);
    });
  }

  // å˜ä¸€URLã®ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰
  function downloadUrl(url: string) {
    const fileName = generateFileName(url);
    const content = createXmlContent(url);
    downloadFile(`${fileName}.webloc`, content);
    showToastMessage(`ã€Œ${fileName}.weblocã€ã‚’ä¿å­˜ã—ãŸã‚ˆï¼`);
  }

  // ã‚¯ã‚¨ãƒªãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã‚’å‰Šé™¤ã™ã‚‹å‡¦ç†
  function removeQueryParams(originalUrl: string, cleanUrl: string) {
    if (originalUrl === cleanUrl) {
      showToastMessage("ã“ã®URLã«ã¯ã‚¯ã‚¨ãƒªãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ãŒãªã„ã‚ˆï¼");
      return;
    }

    extractedUrls = extractedUrls.map(url => url === originalUrl ? cleanUrl : url);
    renderUrlList();
    updateStats();
    showToastMessage("ã‚¯ã‚¨ãƒªãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã‚’å‰Šé™¤ã—ãŸã‚ˆï¼");
  }

  // ã™ã¹ã¦ã®URLã‚’ã¾ã¨ã‚ã¦ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰
  async function downloadAllUrls() {
    if (extractedUrls.length === 0) return;

    // JSZipã‚’ãƒ€ã‚¤ãƒŠãƒŸãƒƒã‚¯ã‚¤ãƒ³ãƒãƒ¼ãƒˆ
    const JSZipModule = await import("jszip");
    const JSZip = JSZipModule.default;
    const zip = new JSZip();

    extractedUrls.forEach(url => {
      const fileName = generateFileName(url);
      const content = createXmlContent(url);
      zip.file(`${fileName}.webloc`, content);
    });

    const blob = await zip.generateAsync({ type: "blob" });
    downloadFile("all_urls.zip", blob);
    showToastMessage("ZIPãƒ•ã‚¡ã‚¤ãƒ«ã‚’ä¿å­˜ã—ãŸã‚ˆï¼");
  }

  // å…¥åŠ›ã¨ãƒªã‚¹ãƒˆã‚’ã‚¯ãƒªã‚¢
  function clearAll() {
    urlInput.value = "";
    extractedUrls = [];
    statusMessage.textContent = "";
    statusMessage.className = "status-message";
    urlListElement.innerHTML = "";
    statsElement.innerHTML = "";
    downloadAllButtonContainer.style.display = "none";
    showToastMessage("ã™ã¹ã¦ã‚¯ãƒªã‚¢ã—ãŸã‚ˆï¼");
  }

  // ãƒ•ã‚¡ã‚¤ãƒ«ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰å…±é€šå‡¦ç†
  function downloadFile(fileName: string, content: string | Blob) {
    const blob = content instanceof Blob ? content : new Blob([content], { type: "application/xml" });
    const link = document.createElement("a");
    link.href = URL.createObjectURL(blob);
    link.download = fileName;
    link.click();
    URL.revokeObjectURL(link.href);
  }

  // ãƒˆãƒ¼ã‚¹ãƒˆè¡¨ç¤ºå‡¦ç†
  function showToastMessage(message: string) {
    toast.textContent = message;
    toast.className = "toast show";
    setTimeout(() => {
      toast.className = "toast";
    }, 3000);
  }

  // ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼ã®è¨­å®š
  clearButton.addEventListener("click", clearAll);
  downloadAllButton.addEventListener("click", downloadAllUrls);
  
  urlInput.addEventListener("input", () => {
    clearTimeout(debounceTimer);
    
    if (!urlInput.value.trim()) {
      clearAll();
      return;
    }
    
    debounceTimer = setTimeout(processInput, 500);
  });
</script> 